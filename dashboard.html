<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Benchmark Results Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="./benchmark_data.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 1rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .results-table {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.9rem;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        th:hover {
            background: #e9ecef;
        }

        th.sortable::after {
            content: ' ‚ÜïÔ∏è';
            font-size: 0.8rem;
            opacity: 0.5;
        }

        th.sort-asc::after {
            content: ' ‚Üë';
            opacity: 1;
            color: #667eea;
        }

        th.sort-desc::after {
            content: ' ‚Üì';
            opacity: 1;
            color: #667eea;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .status-success {
            color: #28a745;
            font-weight: 600;
        }

        .status-failed {
            color: #dc3545;
            font-weight: 600;
        }

        .rps-value {
            font-weight: 600;
            color: #667eea;
        }

        .implementation-tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-right: 5px;
        }

        .rust { background: #deb887; color: #8b4513; }
        .go { background: #add8e6; color: #4682b4; }
        .python { background: #ffd700; color: #b8860b; }
        .javascript { background: #98fb98; color: #228b22; }

        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-weight: 600;
            color: white;
            font-size: 0.9rem;
        }

        select {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .filters {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ API Benchmark Dashboard</h1>
            <p>Performance comparison across different implementations and scenarios</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                üìù To update data: run <code>python3 scripts/generate_dashboard_data.py</code>
            </p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="totalTests">-</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="successfulTests">-</div>
                <div class="stat-label">Successful</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="failedTests">-</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="topRPS">-</div>
                <div class="stat-label">Highest RPS</div>
            </div>
        </div>

        <div class="filters">
            <div class="filter-group">
                <label for="scenarioFilter">Scenario:</label>
                <select id="scenarioFilter">
                    <option value="all">All Scenarios</option>
                    <option value="mixed_light">Light Load</option>
                    <option value="mixed_medium">Medium Load</option>
                    <option value="mixed_heavy">Heavy Load</option>
                    <option value="mixed_extreme">Extreme Load</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="implementationFilter">Implementation:</label>
                <select id="implementationFilter">
                    <option value="all">All Implementations</option>
                </select>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">Performance by Implementation</div>
                <canvas id="performanceChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Success Rate by Scenario</div>
                <canvas id="successChart"></canvas>
            </div>
            <div class="chart-container full-width">
                <div class="chart-title">RPS Comparison Across All Scenarios</div>
                <canvas id="comparisonChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Min Response Times by Scenario</div>
                <canvas id="minRTChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Median Response Times by Scenario</div>
                <canvas id="medRTChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Average Response Times by Scenario</div>
                <canvas id="avgRTChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Max Response Times by Scenario</div>
                <canvas id="maxRTChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">P95 Response Times by Scenario</div>
                <canvas id="p95Chart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">P99 Response Times by Scenario</div>
                <canvas id="p99Chart"></canvas>
            </div>
        </div>

        <div class="results-table">
            <div class="chart-title">Detailed Results</div>
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th class="sortable" data-column="implementation">Implementation</th>
                        <th class="sortable" data-column="test">Scenario</th>
                        <th class="sortable" data-column="vus">VUs</th>
                        <th class="sortable" data-column="duration">Duration</th>
                        <th class="sortable" data-column="rps">RPS</th>
                        <th class="sortable" data-column="avgRT">Avg RT (ms)</th>
                        <th class="sortable" data-column="p95RT">P95 RT (ms)</th>
                        <th class="sortable" data-column="p99RT">P99 RT (ms)</th>
                        <th class="sortable" data-column="status">Status</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Global variables - benchmarkData is loaded from benchmark_data.js
        let filteredData = [];

        // Color schemes
        const implementationColors = {
            'rust-axum': '#ff6b6b',
            'go-fiber': '#4ecdc4',
            'python-fastapi-granian': '#45b7d1',
            'python-fastapi-uvicorn': '#96ceb4',
            'js-bun-native': '#feca57',
            'js-bun-express+bunpg': '#ff9ff3',
            'js-bun-express': '#54a0ff',
            'js-node-express': '#5f27cd'
        };

        let charts = {};
        let currentSort = { column: null, direction: 'asc' };

        // Initialize dashboard
        function initDashboard() {
            try {
                // Check if benchmark data is available
                if (typeof window.benchmarkData === 'undefined') {
                    console.error('Benchmark data not loaded. Make sure benchmark_data.js is included.');
                    showErrorState();
                    return;
                }
                
                // Initialize filtered data
                filteredData = window.benchmarkData;
                
                // Initialize dashboard components
                updateStats();
                populateFilters();
                createCharts();
                populateTable();
                setupEventListeners();
                
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                showErrorState();
            }
        }

        function showErrorState() {
            document.getElementById('totalTests').textContent = 'Error';
            document.getElementById('successfulTests').textContent = 'Error';
            document.getElementById('failedTests').textContent = 'Error';
            document.getElementById('topRPS').textContent = 'Error';
        }

        function updateStats() {
            const totalTests = filteredData.length;
            const successfulTests = filteredData.filter(d => d.status === 'success').length;
            const failedTests = totalTests - successfulTests;
            const topRPS = Math.max(...filteredData.filter(d => d.rps).map(d => d.rps));

            document.getElementById('totalTests').textContent = totalTests;
            document.getElementById('successfulTests').textContent = successfulTests;
            document.getElementById('failedTests').textContent = failedTests;
            document.getElementById('topRPS').textContent = topRPS ? Math.round(topRPS).toLocaleString() : '-';
        }

        function populateFilters() {
            const implementations = [...new Set(window.benchmarkData.map(d => d.implementation))];
            const implementationSelect = document.getElementById('implementationFilter');
            
            implementations.forEach(impl => {
                const option = document.createElement('option');
                option.value = impl;
                option.textContent = impl;
                implementationSelect.appendChild(option);
            });
        }

        function createCharts() {
            createPerformanceChart();
            createSuccessChart();
            createComparisonChart();
            createMinRTChart();
            createMedRTChart();
            createAvgRTChart();
            createMaxRTChart();
            createP95Chart();
            createP99Chart();
        }

        function createPerformanceChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            const avgRPSByImpl = {};
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            implementations.forEach(impl => {
                const implData = filteredData.filter(d => d.implementation === impl && d.rps);
                avgRPSByImpl[impl] = implData.length > 0 ? 
                    implData.reduce((sum, d) => sum + d.rps, 0) / implData.length : 0;
            });

            if (charts.performance) charts.performance.destroy();
            
            charts.performance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: implementations,
                    datasets: [{
                        label: 'Average RPS',
                        data: implementations.map(impl => avgRPSByImpl[impl]),
                        backgroundColor: implementations.map(impl => implementationColors[impl]),
                        borderRadius: 8,
                        borderSkipped: false,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Requests per Second'
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45
                            }
                        }
                    }
                }
            });
        }

        function createSuccessChart() {
            const ctx = document.getElementById('successChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const successRates = scenarios.map(scenario => {
                const scenarioData = filteredData.filter(d => d.test === scenario);
                const successCount = scenarioData.filter(d => d.status === 'success').length;
                return scenarioData.length > 0 ? (successCount / scenarioData.length) * 100 : 0;
            });

            if (charts.success) charts.success.destroy();
            
            charts.success = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: [{
                        label: 'Success Rate (%)',
                        data: successRates,
                        backgroundColor: ['#28a745', '#ffc107', '#fd7e14', '#dc3545'],
                        borderRadius: 8,
                        borderSkipped: false,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Success Rate (%)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Load Scenario'
                            }
                        }
                    }
                }
            });
        }

        function createComparisonChart() {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.rps ? entry.rps : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.comparison) charts.comparison.destroy();
            
            charts.comparison = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Requests per Second'
                            }
                        }
                    }
                }
            });
        }

        function createMinRTChart() {
            const ctx = document.getElementById('minRTChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.min : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.minRT) charts.minRT.destroy();
            
            charts.minRT = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Min Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function createMedRTChart() {
            const ctx = document.getElementById('medRTChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.med : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.medRT) charts.medRT.destroy();
            
            charts.medRT = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Median Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function createAvgRTChart() {
            const ctx = document.getElementById('avgRTChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.avg : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.avgRT) charts.avgRT.destroy();
            
            charts.avgRT = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function createMaxRTChart() {
            const ctx = document.getElementById('maxRTChart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.max : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.maxRT) charts.maxRT.destroy();
            
            charts.maxRT = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Max Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function createP95Chart() {
            const ctx = document.getElementById('p95Chart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.p95 : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.p95) charts.p95.destroy();
            
            charts.p95 = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'P95 Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function createP99Chart() {
            const ctx = document.getElementById('p99Chart').getContext('2d');
            
            const scenarios = ['mixed_light', 'mixed_medium', 'mixed_heavy', 'mixed_extreme'];
            const implementations = [...new Set(filteredData.map(d => d.implementation))];
            
            const datasets = implementations.map(impl => ({
                label: impl,
                data: scenarios.map(scenario => {
                    const entry = filteredData.find(d => d.implementation === impl && d.test === scenario);
                    return entry && entry.responseTime ? entry.responseTime.p99 : null;
                }),
                borderColor: implementationColors[impl],
                backgroundColor: implementationColors[impl] + '20',
                fill: false,
                tension: 0.1,
                spanGaps: false
            }));

            if (charts.p99) charts.p99.destroy();
            
            charts.p99 = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: scenarios.map(s => s.replace('mixed_', '').toUpperCase()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'P99 Response Time (ms)'
                            }
                        }
                    }
                }
            });
        }

        function populateTable() {
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            
            filteredData.forEach(row => {
                const tr = document.createElement('tr');
                
                const implClass = row.implementation.startsWith('rust') ? 'rust' :
                                 row.implementation.startsWith('go') ? 'go' :
                                 row.implementation.startsWith('python') ? 'python' : 'javascript';
                
                tr.innerHTML = `
                    <td><span class="implementation-tag ${implClass}">${row.implementation}</span></td>
                    <td>${row.test.replace('mixed_', '').toUpperCase()}</td>
                    <td>${row.vus}</td>
                    <td>${row.duration}</td>
                    <td class="rps-value">${row.rps ? Math.round(row.rps).toLocaleString() : 'N/A'}</td>
                    <td class="rps-value">${row.responseTime ? Math.round(row.responseTime.avg * 100) / 100 : 'N/A'}</td>
                    <td class="rps-value">${row.responseTime ? Math.round(row.responseTime.p95 * 100) / 100 : 'N/A'}</td>
                    <td class="rps-value">${row.responseTime ? Math.round(row.responseTime.p99 * 100) / 100 : 'N/A'}</td>
                    <td class="status-${row.status}">${row.status.toUpperCase()}</td>
                `;
                
                tbody.appendChild(tr);
            });
        }

        function setupEventListeners() {
            document.getElementById('scenarioFilter').addEventListener('change', filterData);
            document.getElementById('implementationFilter').addEventListener('change', filterData);
            
            // Add sorting event listeners to table headers
            document.querySelectorAll('th.sortable').forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.column;
                    sortTable(column);
                });
            });
        }

        function sortTable(column) {
            // Toggle sort direction if clicking the same column
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }

            // Update header visual indicators
            document.querySelectorAll('th.sortable').forEach(header => {
                header.classList.remove('sort-asc', 'sort-desc');
                if (header.dataset.column === column) {
                    header.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });

            // Sort the data
            filteredData.sort((a, b) => {
                let valueA, valueB;

                switch (column) {
                    case 'implementation':
                        valueA = a.implementation;
                        valueB = b.implementation;
                        break;
                    case 'test':
                        valueA = a.test;
                        valueB = b.test;
                        break;
                    case 'vus':
                        valueA = a.vus;
                        valueB = b.vus;
                        break;
                    case 'duration':
                        valueA = a.duration;
                        valueB = b.duration;
                        break;
                    case 'rps':
                        valueA = a.rps || 0;
                        valueB = b.rps || 0;
                        break;
                    case 'avgRT':
                        valueA = a.responseTime ? a.responseTime.avg : 999999;
                        valueB = b.responseTime ? b.responseTime.avg : 999999;
                        break;
                    case 'p95RT':
                        valueA = a.responseTime ? a.responseTime.p95 : 999999;
                        valueB = b.responseTime ? b.responseTime.p95 : 999999;
                        break;
                    case 'p99RT':
                        valueA = a.responseTime ? a.responseTime.p99 : 999999;
                        valueB = b.responseTime ? b.responseTime.p99 : 999999;
                        break;
                    case 'status':
                        valueA = a.status;
                        valueB = b.status;
                        break;
                    default:
                        return 0;
                }

                // Handle different data types
                if (typeof valueA === 'string' && typeof valueB === 'string') {
                    valueA = valueA.toLowerCase();
                    valueB = valueB.toLowerCase();
                }

                let comparison = 0;
                if (valueA > valueB) {
                    comparison = 1;
                } else if (valueA < valueB) {
                    comparison = -1;
                }

                return currentSort.direction === 'desc' ? comparison * -1 : comparison;
            });

            // Repopulate the table
            populateTable();
        }

        function applySorting() {
            if (!currentSort.column) return;

            const column = currentSort.column;
            
            filteredData.sort((a, b) => {
                let valueA, valueB;

                switch (column) {
                    case 'implementation':
                        valueA = a.implementation;
                        valueB = b.implementation;
                        break;
                    case 'test':
                        valueA = a.test;
                        valueB = b.test;
                        break;
                    case 'vus':
                        valueA = a.vus;
                        valueB = b.vus;
                        break;
                    case 'duration':
                        valueA = a.duration;
                        valueB = b.duration;
                        break;
                    case 'rps':
                        valueA = a.rps || 0;
                        valueB = b.rps || 0;
                        break;
                    case 'avgRT':
                        valueA = a.responseTime ? a.responseTime.avg : 999999;
                        valueB = b.responseTime ? b.responseTime.avg : 999999;
                        break;
                    case 'p95RT':
                        valueA = a.responseTime ? a.responseTime.p95 : 999999;
                        valueB = b.responseTime ? b.responseTime.p95 : 999999;
                        break;
                    case 'p99RT':
                        valueA = a.responseTime ? a.responseTime.p99 : 999999;
                        valueB = b.responseTime ? b.responseTime.p99 : 999999;
                        break;
                    case 'status':
                        valueA = a.status;
                        valueB = b.status;
                        break;
                    default:
                        return 0;
                }

                // Handle different data types
                if (typeof valueA === 'string' && typeof valueB === 'string') {
                    valueA = valueA.toLowerCase();
                    valueB = valueB.toLowerCase();
                }

                let comparison = 0;
                if (valueA > valueB) {
                    comparison = 1;
                } else if (valueA < valueB) {
                    comparison = -1;
                }

                return currentSort.direction === 'desc' ? comparison * -1 : comparison;
            });
        }

        function filterData() {
            const scenarioFilter = document.getElementById('scenarioFilter').value;
            const implementationFilter = document.getElementById('implementationFilter').value;
            
            filteredData = window.benchmarkData.filter(d => {
                const scenarioMatch = scenarioFilter === 'all' || d.test === scenarioFilter;
                const implMatch = implementationFilter === 'all' || d.implementation === implementationFilter;
                return scenarioMatch && implMatch;
            });
            
            // Reapply current sort if one exists
            if (currentSort.column) {
                // Apply sorting without calling sortTable to avoid recursion
                applySorting();
            }
            
            updateStats();
            createCharts();
            populateTable();
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>
